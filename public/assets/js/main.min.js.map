{"version":3,"sources":["assets/js/main.js"],"names":["$","window","on","vh","innerHeight","css","trigger","$video","document","querySelector","$canvas","ctx","getContext","streamObj","front","loadedDataHandler","camera","frameReady","cameraStart","openCam","navigator","mediaDevices","getUserMedia","video","facingMode","width","ideal","height","then","async","stream","srcObject","removeEventListener","Promise","resolve","reject","videoWidth","videoHeight","addEventListener","await","img","Image","src","faceMesh","FaceMesh","locateFile","file","setOptions","maxNumFaces","refineLandmarks","minDetectionConfidence","minTrackingConfidence","onResults","results","requestAnimationFrame","clearRect","save","translate","scale","drawImage","image","multiFaceLandmarks","landmarks","drawConnectors","FACEMESH_LIPS","color","length","minX","Infinity","minY","maxX","maxY","point","x","y","Math","min","max","faceWidth","innerWidth","topOfHead","imgW","restore","Camera","onFrame","send","append","addClass","start","catch","error","alert","message","name","removeClass","getTracks","forEach","track","stop"],"mappings":"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","file":"main.min.js","sourcesContent":["$(function () {\n    $(window).on('resize.vh', function () {\n        var vh = window.innerHeight * 0.01;\n        $('html').css('--vh', vh + 'px');\n    }).trigger('resize.vh');\n    const $video = document.querySelector('[data-camera-video]');\n    const $canvas = document.querySelector('[data-camera-canvas]');\n    const ctx = $canvas.getContext('2d');\n    let streamObj; // 預計用來存放 串流相關的物件(MediaStream)\n    let front = true;\n    let loadedDataHandler; // 全局變數存儲 loadeddata 事件處理程序\n    let camera;\n\n    let frameReady = false;\n    let cameraStart = false;\n\n    // 開啟 webcam\n    openCam();\n    function openCam() {\n        cameraStart = false;\n        frameReady = false;\n\n        // 開啟視訊鏡頭，瀏覽器會跳詢問視窗\n        navigator.mediaDevices.getUserMedia({\n            video: {\n                facingMode: front ? 'user' : 'environment',\n                width: {\n                    ideal: 2400\n                },\n                height: {\n                    ideal: 3200\n                }\n            }\n        }).then(async function (stream) {\n            streamObj = stream; // 將串流物件放在 streamObj 全域變數，方便後面關閉 webcam 時會用到\n            $video.srcObject = stream; // video 標籤顯示 webcam 畫面\n\n            // 先移除之前的事件綁定\n            if (loadedDataHandler) {\n                $video.removeEventListener('loadeddata', loadedDataHandler);\n            }\n            const addLoadedDataHandler = new Promise((resolve, reject) => {\n                // 重新定義並綁定 loadeddata 事件\n                loadedDataHandler = function () {\n                    // 將 video 標籤的影片寬高，顯示於 canvas 標籤上\n                    $canvas.width = $video.videoWidth;\n                    $canvas.height = $video.videoHeight;\n\n                    resolve();\n                };\n\n                // 綁定事件\n                $video.addEventListener('loadeddata', loadedDataHandler, false);\n            });\n            await addLoadedDataHandler;\n            const img = new Image();\n            img.src = './assets/image/touch/logo.png'; // 你想顯示的圖片路徑\n\n            const faceMesh = new FaceMesh({\n                locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`\n            });\n            faceMesh.setOptions({\n                maxNumFaces: 1,\n                refineLandmarks: true,\n                minDetectionConfidence: 0.5,\n                minTrackingConfidence: 0.5\n            });\n            faceMesh.onResults(onResults);\n            function onResults(results) {\n                requestAnimationFrame(() => {\n                    // 清空Canvas\n                    ctx.clearRect(0, 0, $canvas.width, $canvas.height);\n                    ctx.save();\n                    if (front) {\n                        // 水平反轉\n                        ctx.translate($canvas.width, 0);\n                        ctx.scale(-1, 1);\n                    }\n                    ctx.drawImage(results.image, 0, 0, $canvas.width, $canvas.height);\n                    if (results.multiFaceLandmarks) {\n                        for (const landmarks of results.multiFaceLandmarks) {\n                            // drawConnectors(ctx, landmarks, FACEMESH_TESSELATION,\n                            //     { color: '#C0C0C070', lineWidth: 1 });\n                            // drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, { color: '#FF3030' });\n                            // drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, { color: '#30FF30' });\n                            // drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, { color: '#E0E0E0' });\n                            drawConnectors(ctx, landmarks, FACEMESH_LIPS, {\n                                color: '#E0E0E0'\n                            });\n                        }\n                    }\n                    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {\n                        const landmarks = results.multiFaceLandmarks[0];\n\n                        // 計算臉部的外接矩形範圍\n                        let minX = Infinity,\n                            minY = Infinity,\n                            maxX = -Infinity,\n                            maxY = -Infinity;\n                        for (const point of landmarks) {\n                            const x = point.x * $canvas.width;\n                            const y = point.y * $canvas.height;\n                            minX = Math.min(minX, x);\n                            minY = Math.min(minY, y);\n                            maxX = Math.max(maxX, x);\n                            maxY = Math.max(maxY, y);\n                        }\n\n                        // 計算臉部面積\n                        const faceWidth = maxX - minX;\n                        const faceHeight = maxY - minY;\n                        const faceArea = faceWidth * faceHeight;\n\n                        // 根據面積調整圖片大小，面積越大，頭越近\n                        const scale = faceArea / (window.innerWidth * window.innerHeight);\n                        // $('.text').text(scale);\n\n                        // 計算頭頂的座標\n                        const topOfHead = landmarks[10];\n                        const x = topOfHead.x * $canvas.width;\n                        const y = topOfHead.y * $canvas.height;\n                        const imgW = faceWidth + scale * 10;\n                        // 根據比例繪製圖片\n                        ctx.drawImage(img, x - imgW / 2, y - imgW, imgW, imgW);\n                    }\n                    ctx.restore();\n                });\n            }\n            camera = new Camera($video, {\n                onFrame: async () => {\n                    await faceMesh.send({\n                        image: $video\n                    });\n\n                    if (!frameReady) {\n                        frameReady = true;\n                        $('.text').append('<br>frameReady');\n                    }\n                    if (frameReady && cameraStart) {\n                        $('.camera-loading').addClass('hide');\n                    }\n                },\n                width: $video.videoWidth,\n                height: $video.videoHeight,\n                facingMode: front ? 'user' : 'environment'\n            });\n            camera.start();\n            if (!cameraStart) {\n                cameraStart = true;\n                $('.text').append('<br>cameraStart');\n            }\n            if (frameReady && cameraStart) {\n                $('.camera-loading').addClass('hide');\n            }\n\n        }).catch(function (error) {\n            // 若無法取得畫面，執行 catch\n            alert('取得相機訪問權限失敗: ', error.message, error.name);\n        });\n    }\n\n    $('[data-camera-direction]').on('click', function () {\n        $('.camera-loading').removeClass('hide');\n        streamObj.getTracks().forEach(track => track.stop());\n        if (camera) {\n            camera.stop(); // 停止之前的 Camera\n        }\n        front = !front;\n        openCam();\n        // restartMediaPipeCamera(); // 重新啟動 MediaPipe Camera\n    });\n\n    // // 初始化並啟動 MediaPipe Camera\n    // function startMediaPipeCamera() {\n\n    // }\n\n    // // 停止並重新啟動 MediaPipe Camera\n    // function restartMediaPipeCamera() {\n    //     if (camera) {\n    //         camera.stop(); // 停止之前的 Camera\n    //     }\n    //     startMediaPipeCamera(); // 重新啟動\n    // }\n\n    // // 啟動 MediaPipe Camera\n    // startMediaPipeCamera();\n});"],"sourceRoot":"/"}