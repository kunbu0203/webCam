{"version":3,"sources":["assets/js/main.js"],"names":["$","window","on","vh","innerHeight","css","trigger","img","Image","src","food","foodW","streamObj","camera","front","frameReady","cameraStart","gameStart","point","faceMesh","FaceMesh","locateFile","file","openCam","type","$video","document","createElement","setAttribute","querySelector","appendChild","$canvas","ctx","getContext","loadedDataHandler","navigator","mediaDevices","getUserMedia","video","facingMode","width","ideal","height","then","async","stream","srcObject","removeEventListener","Promise","resolve","reject","videoWidth","videoHeight","addEventListener","await","ballY1","ballY2","onResults","results","requestAnimationFrame","clearRect","save","translate","scale","drawImage","image","multiFaceLandmarks","length","landmarks","minX","Infinity","minY","maxX","maxY","x","y","Math","min","max","faceWidth","innerWidth","topOfHead","imgW","upperLip","lowerLip","mouthOpenDistance","abs","addClass","removeClass","lipCenter","leftMouthCorner","rightMouthCorner","ballXCenter","ballX","ballXCenter2","ballX2","hide","text","restore","Camera","onFrame","send","start","catch","error","alert","message","name","off","resultImg","toDataURL","attr","setOptions","maxNumFaces","refineLandmarks","minDetectionConfidence","minTrackingConfidence","getTracks","forEach","track","stop","innerHTML","setTimeout"],"mappings":"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","file":"main.min.js","sourcesContent":["$(function () {\n    $(window).on('resize.vh', function () {\n        var vh = window.innerHeight * 0.01;\n        $('html').css('--vh', vh + 'px');\n    }).trigger('resize.vh');\n\n    const img = new Image();\n    img.src = './assets/image/touch/logo.png'; // 你想顯示的圖片路徑\n    const food = new Image();\n    food.src = './assets/image/food.svg'; // 你想顯示的圖片路徑\n    let foodW = 0;\n\n    let streamObj; // 預計用來存放 串流相關的物件(MediaStream)\n    let camera;\n\n    let front = true;\n    let frameReady = false;\n    let cameraStart = false;\n\n    let gameStart = false;\n    let point = 0;\n\n    const faceMesh = new FaceMesh({\n        locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`\n    });\n    faceMesh.setOptions({\n        maxNumFaces: 1,\n        refineLandmarks: true,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n    });\n\n    // 開啟 webcam\n    openCam('user');\n    function openCam(type) {\n        const $video = document.createElement('video');\n        $video.setAttribute('playsinline', '');\n        $video.setAttribute('autoplay', '');\n        $video.setAttribute('muted', '');\n        document.querySelector('.camera-video').appendChild($video);\n\n        const $canvas = document.createElement('canvas');\n        document.querySelector('.camera-screen').appendChild($canvas);\n\n        const ctx = $canvas.getContext('2d');\n        let loadedDataHandler; // 全局變數存儲 loadeddata 事件處理程序\n\n        // 開啟視訊鏡頭，瀏覽器會跳詢問視窗\n        navigator.mediaDevices.getUserMedia({\n            video: {\n                facingMode: type,\n                width: {\n                    ideal: 2400\n                },\n                height: {\n                    ideal: 3200\n                }\n            }\n        }).then(async function (stream) {\n            streamObj = stream; // 將串流物件放在 streamObj 全域變數，方便後面關閉 webcam 時會用到\n            $video.srcObject = stream; // video 標籤顯示 webcam 畫面\n\n            // 先移除之前的事件綁定\n            if (loadedDataHandler) {\n                $video.removeEventListener('loadeddata', loadedDataHandler);\n            }\n            const addLoadedDataHandler = new Promise((resolve, reject) => {\n                // 重新定義並綁定 loadeddata 事件\n                loadedDataHandler = function () {\n                    // 將 video 標籤的影片寬高，顯示於 canvas 標籤上\n                    $canvas.width = $video.videoWidth;\n                    $canvas.height = $video.videoHeight;\n\n                    foodW = $canvas.width * 0.15;\n\n                    resolve();\n                };\n\n                // 綁定事件\n                $video.addEventListener('loadeddata', loadedDataHandler, false);\n            });\n            await addLoadedDataHandler;\n\n            let ballY1 = (foodW * -1);\n            let ballY2 = (foodW * -5);\n\n            faceMesh.onResults(onResults);\n            function onResults(results) {\n                requestAnimationFrame(() => {\n                    // 清空Canvas\n                    ctx.clearRect(0, 0, $canvas.width, $canvas.height);\n                    ctx.save();\n                    if (type === 'user') {\n                        // 水平反轉\n                        ctx.translate($canvas.width, 0);\n                        ctx.scale(-1, 1);\n                    }\n                    ctx.drawImage(results.image, 0, 0, $canvas.width, $canvas.height);\n                    // if (results.multiFaceLandmarks) {\n                    //     for (const landmarks of results.multiFaceLandmarks) {\n                    //         // drawConnectors(ctx, landmarks, FACEMESH_TESSELATION,\n                    //         //     { color: '#C0C0C070', lineWidth: 1 });\n                    //         // drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, { color: '#FF3030' });\n                    //         // drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, { color: '#30FF30' });\n                    //         // drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, { color: '#E0E0E0' });\n                    //         drawConnectors(ctx, landmarks, FACEMESH_LIPS, {\n                    //             color: '#E0E0E0'\n                    //         });\n                    //     }\n                    // }\n                    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {\n                        const landmarks = results.multiFaceLandmarks[0];\n\n                        // 計算臉部的外接矩形範圍\n                        let minX = Infinity,\n                            minY = Infinity,\n                            maxX = -Infinity,\n                            maxY = -Infinity;\n                        for (const point of landmarks) {\n                            const x = point.x * $canvas.width;\n                            const y = point.y * $canvas.height;\n                            minX = Math.min(minX, x);\n                            minY = Math.min(minY, y);\n                            maxX = Math.max(maxX, x);\n                            maxY = Math.max(maxY, y);\n                        }\n\n                        // 計算臉部面積\n                        const faceWidth = maxX - minX;\n                        const faceHeight = maxY - minY;\n                        const faceArea = faceWidth * faceHeight;\n\n                        // 根據面積調整圖片大小，面積越大，頭越近\n                        const scale = faceArea / (window.innerWidth * window.innerHeight);\n\n                        // 計算頭頂的座標\n                        const topOfHead = landmarks[10];\n                        const x = topOfHead.x * $canvas.width;\n                        const y = topOfHead.y * $canvas.height;\n                        const imgW = faceWidth + scale * 10;\n                        // 根據比例繪製圖片\n                        ctx.drawImage(img, x - imgW / 2, y - imgW, imgW, imgW);\n\n                        // 嘴巴張開偵測\n                        const upperLip = landmarks[13];\n                        const lowerLip = landmarks[14];\n                        const mouthOpenDistance = Math.abs(upperLip.y - lowerLip.y);\n\n                        // 設定一個閾值，當距離大於這個值時視為張嘴\n                        if (mouthOpenDistance > 0.05) {\n                            $('.camera-text').addClass('hide');\n\n                            if (!gameStart) {\n                                gameStart = true;\n                            }\n                        } else {\n                            $('.camera-text').removeClass('hide');\n                        }\n\n                        if (gameStart) {\n                            const lipCenter = (upperLip.y + lowerLip.y) / 2;\n                            const leftMouthCorner = landmarks[61].x * $canvas.width;\n                            const rightMouthCorner = landmarks[291].x * $canvas.width;\n                            const ballX = $canvas.width - (foodW * 2);\n                            const ballXCenter = ballX + (foodW / 2);\n                            const ballX2 = $canvas.width - (foodW * 6);\n                            const ballXCenter2 = ballX2 + (foodW / 2);\n\n                            if (ballY1 > $canvas.height) {\n                                ballY1 = (foodW * -2);\n                            }\n                            if (ballY1 + (foodW / 2) > lipCenter * $canvas.height && leftMouthCorner < ballXCenter && rightMouthCorner > ballXCenter && mouthOpenDistance > 0.05) {\n                                ballY1 = (foodW * -2);\n                                point++;\n                            }\n                            if (ballY2 > $canvas.height) {\n                                ballY2 = (foodW * -4);\n                            }\n                            if (ballY2 + (foodW / 2) > lipCenter * $canvas.height && leftMouthCorner < ballXCenter2 && rightMouthCorner > ballXCenter2 && mouthOpenDistance > 0.05) {\n                                ballY2 = (foodW * -4);\n                                point++;\n                            }\n\n                            $('.camera-direction').hide();\n                            ctx.drawImage(food, ballX, ballY1, foodW, foodW);\n                            ballY1 += (foodW * 0.1);\n                            ctx.drawImage(food, ballX2, ballY2, foodW, foodW);\n                            ballY2 += (foodW * 0.08);\n                        }\n                    }\n\n                    $('.text').text(point);\n                    ctx.restore();\n                });\n            }\n            camera = new Camera($video, {\n                onFrame: async () => {\n                    await faceMesh.send({\n                        image: $video\n                    });\n\n                    if (!frameReady) {\n                        frameReady = true;\n                    }\n                    if (frameReady && cameraStart) {\n                        $('.loading').addClass('hide');\n                    }\n                },\n                width: $video.videoWidth,\n                height: $video.videoHeight,\n                facingMode: type\n            });\n            camera.start();\n            if (!cameraStart) {\n                cameraStart = true;\n            }\n            if (frameReady && cameraStart) {\n                $('.loading').addClass('hide');\n            }\n\n        }).catch(function (error) {\n            // 若無法取得畫面，執行 catch\n            alert('取得相機訪問權限失敗: ', error.message, error.name);\n        });\n\n        // 拍照\n        $('[data-camera-taking]').off('click').on('click', function () {\n            resultImg = $canvas.toDataURL('image/jpeg', 1.0);\n            $('[data-pic]').attr('src', resultImg);\n        });\n    }\n\n    $(`[data-camera-direction]`).off('click.direction').on('click.direction', function () {\n        $('.loading').removeClass('hide');\n        streamObj.getTracks().forEach(track => track.stop());\n        if (camera) {\n            camera.stop(); // 停止之前的 Camera\n        }\n        document.querySelector('.camera-video').innerHTML = '';\n        document.querySelector('.camera-screen').innerHTML = '';\n        frameReady = false;\n        cameraStart = false;\n\n        front = !front;\n        setTimeout(() => {\n            openCam(!front ? 'environment' : 'user');\n        }, 0);\n    });\n});"],"sourceRoot":"/"}